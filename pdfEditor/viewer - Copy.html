<!DOCTYPE html>
<html>
<head>
  <title>PDF Viewer from Scratch</title>
</head>
<body>
  <h2>Upload PDF</h2>
  <input type="file" id="pdfInput" accept=".pdf">
  <canvas id="pdfCanvas" width="612" height="792" style="border:1px solid #ccc;"></canvas>

  <pre id="output"></pre>

  <script>
  document.getElementById('pdfInput').addEventListener('change', function (e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = function () {
      const arrayBuffer = reader.result;
      const uint8 = new Uint8Array(arrayBuffer);
      const text = new TextDecoder("iso-8859-1").decode(uint8);

      // Preview content
      document.getElementById("output").textContent = text.slice(0, 500);

      // ‚úÖ STEP 1: Locate startxref
      const startxrefIndex = text.lastIndexOf("startxref");
      if (startxrefIndex === -1) {
        console.log("‚ùå startxref not found.");
        return;
      }

      const startxrefText = text.slice(startxrefIndex, startxrefIndex + 50);
      const offsetMatch = startxrefText.match(/\d+/);  // ‚úÖ defining offsetMatch

      if (!offsetMatch) {
        console.log("‚ùå xref offset not found.");
        return;
      }

	  const xrefOffset = parseInt(offsetMatch[0]);
      console.log("‚úÖ Found startxref offset:", xrefOffset);

      // ‚úÖ STEP 2: Parse xref table
      const xrefSection = text.slice(xrefOffset, xrefOffset + 300);  // take a chunk
      console.log("üîç XRef Section Preview:\n" + xrefSection);

      const lines = xrefSection.split("\n");
      let objMap = {};
      let objStart = -1;
      let count = 0;

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i].trim();

			if (line === "xref") continue;

			const headerMatch = line.match(/^(\d+)\s+(\d+)$/);
			if (headerMatch) {
				objStart = parseInt(headerMatch[1]);
				count = parseInt(headerMatch[2]);
				continue;
			}

			const entryMatch = line.match(/^(\d{10})\s+(\d{5})\s+n$/);
			if (entryMatch && objStart !== -1) {
				const offset = parseInt(entryMatch[1]);
				const objId = objStart++;
				objMap[objId] = offset;
			}
		}

		console.log("üìå Object Map:", objMap);
	  
		for (const objId in objMap) {
			const offset = objMap[objId];
			let objText = "";

			for (let i = offset; i < uint8.length - 1; i++) {
				const slice = new TextDecoder("iso-8859-1").decode(uint8.slice(i, i + 6));
				if (slice === "endob") break; // typo case
				if (slice === "endobj") {
					const safeOffset = Math.max(0, offset - 20);  // ‚úÖ added
					objText = new TextDecoder("iso-8859-1").decode(uint8.slice(safeOffset, i + 6));
					break;
				}
			}

			console.log(`üì¶ Object ${objId} Content:\n`, objText);

			if (objText.includes("stream")) {
				const streamMatch = objText.match(/stream\s*([\s\S]*?)\s*endstream/);
				if (streamMatch) {
					const streamText = streamMatch[1].trim();
					console.log(`üìù Stream from Object ${objId}:\n`, streamText);
				} else {
				console.log(`‚ùå Stream not found in Object ${objId}`);
				}
			} else {
				console.log(`‚ùå Object ${objId} has no stream.`);
			}
			
			const streamMatch = objText.match(/stream\s*(.*?)\s*endstream/is);

			if (streamMatch) {
				const streamText = streamMatch[1].trim();
				console.log("üìù Stream Content:\n", streamText);

				const textMatch = streamText.match(/\(\s*([^)]*?)\s*\)\s*Tj/);

				const text = textMatch ? textMatch[1] : "Unknown";

				const posMatch = streamText.match(/(\d+)\s+(\d+)\s+Td/);
				const x = posMatch ? parseInt(posMatch[1]) : 100;
				const y = posMatch ? 792 - parseInt(posMatch[2]) : 100;

				const sizeMatch = streamText.match(/\/F1\s+(\d+)\s+Tf/);
				const fontSize = sizeMatch ? parseInt(sizeMatch[1]) : 16;

				const canvas = document.getElementById("pdfCanvas");
				const ctx = canvas.getContext("2d");
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.font = `${fontSize}px Helvetica`;
				ctx.fillText(text, x, y); // ‚úÖ now y is already flipped
			}
			
			// ‚úÖ Check for compressed stream
			if (objText.includes("/FlateDecode")) {
				const streamStart = objText.indexOf("stream");
				const streamEnd = objText.indexOf("endstream");

				if (streamStart === -1 || streamEnd === -1) return;

				const preStream = new TextEncoder().encode(objText.slice(0, streamStart));
				const postStream = new TextEncoder().encode(objText.slice(0, streamEnd));
				const streamStartIndex = offset + preStream.length + 1; // +1 to skip newline
				const streamEndIndex = offset + postStream.length;

				const compressedBytes = uint8.slice(streamStartIndex, streamEndIndex);

				const ds = new DecompressionStream('deflate');
				const decompressedStream = new Blob([compressedBytes]).stream().pipeThrough(ds);
				const reader = decompressedStream.getReader();
				const chunks = [];

				(async () => {
					while (true) {
						const { done, value } = await reader.read();
						if (done) break;
						chunks.push(value);
					}

					const decompressedBlob = new Blob(chunks);
					const streamText = await decompressedBlob.text();
					console.log("üóÉÔ∏è Decompressed Stream:\n", streamText);
	
					// ‚¨áÔ∏è Existing draw code (reused)
					const textMatch = streamText.match(/\(\s*([^)]*?)\s*\)\s*Tj/);
					const text = textMatch ? textMatch[1] : "Unknown";

					const posMatch = streamText.match(/(\d+)\s+(\d+)\s+Td/);
					const x = posMatch ? parseInt(posMatch[1]) : 100;
					const y = posMatch ? 792 - parseInt(posMatch[2]) : 100;
	
					const sizeMatch = streamText.match(/\/F1\s+(\d+)\s+Tf/);
					const fontSize = sizeMatch ? parseInt(sizeMatch[1]) : 16;

					const canvas = document.getElementById("pdfCanvas");
					const ctx = canvas.getContext("2d");
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					ctx.font = `${fontSize}px Helvetica`;
					ctx.fillText(text, x, y);
				})();
			}
		}
    };

    reader.readAsArrayBuffer(file);
  });
</script>


</body>
</html>
